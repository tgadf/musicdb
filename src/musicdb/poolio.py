""" Parallel processing for parse/merge/concat, meta, summary, and match IO """__all__ = ["PoolIO"]from dbbase import getModValsfrom utils import headerfrom multiprocessing import Poolfrom tqdm import tqdmimport inspectfrom functools import partialfrom .iostore import getdbio################################################################################ PoolIO###############################################################################class PoolIO:    def __repr__(self):        return f"PoolIO(db={self.db})"            def __init__(self, db, **kwargs):        self.db = db        verbose = kwargs.get('verbose', False)        local = kwargs.get('local', False)        mod = kwargs.get('mod', False)                dbio = getdbio(db, local=local, mod=mod, verbose=verbose)        assert dbio is not None, f"Could not get dbio for db [{db}]"        self.dbio = dbio                nProcs = kwargs.get('nProcs', 7)        assert isinstance(nProcs, int), f"nProcs [{nProcs}] must be an int"        self.nProcs = nProcs                    ###########################################################################    # Parse    ###########################################################################    def parse(self, *arg, **kwargs) -> 'None':        key = arg[0] if len(arg) == 1 else None        if isinstance(key, str):            procs = self.dbio.pdio.procs            assert key in procs.keys(), f"parse key [{key}] is not allowed: {list(procs.keys())}"        force = kwargs.get('force', True)        modVals = kwargs.get('modVal', getModVals())        self.nProcs = min([len(modVals), self.nProcs])                header(f"{self.__repr__()}.parse(key={key}, nModVals={len(modVals)}, nProcs={self.nProcs})", width=125)        parseFunc = partial(self.dbio.pdio.parse, key=key, force=force)        self.tqdmMap(func=parseFunc, modVals=modVals)                    ###########################################################################    # Concat    ###########################################################################    def concat(self, *arg, **kwargs) -> 'None':        key = arg[0] if len(arg) == 1 else None        if isinstance(key, str):            procs = self.dbio.cdio.procs            assert key in procs.keys(), f"concat key [{key}] is not allowed: {list(procs.keys())}"        force = kwargs.get('force', True)        modVals = kwargs.get('modVal', getModVals())        self.nProcs = min([len(modVals), self.nProcs])                header(f"{self.__repr__()}.concat(key={key}, nModVals={len(modVals)}, nProcs={self.nProcs})", width=125)        concatFunc = partial(self.dbio.cdio.concat, key=key, force=force)        self.tqdmMap(func=concatFunc, modVals=modVals)                    ###########################################################################    # Meta    ###########################################################################    def metaprod(self, *arg, **kwargs) -> 'None':        key = arg[0] if len(arg) == 1 else None        if isinstance(key, str):            procs = self.dbio.metaprodio.dbmetas            assert key in procs.keys(), f"meta key [{key}] is not allowed: {list(procs.keys())}"        force = kwargs.get('force', True)        modVals = kwargs.get('modVal', getModVals())        self.nProcs = min([len(modVals), self.nProcs])                header(f"{self.__repr__()}.metaprod(key={key}, nModVals={len(modVals)}, nProcs={self.nProcs})", width=125)        metaFunc = partial(self.dbio.metaprodio.make, key=key, force=force)        self.tqdmMap(func=metaFunc, modVals=modVals)                    ###########################################################################    # Summary    ###########################################################################    def sumprod(self, *arg, **kwargs) -> 'None':        key = arg[0] if len(arg) == 1 else None        if isinstance(key, str):            procs = self.dbio.sumprodio.dbsums            assert key in procs.keys(), f"summary key [{key}] is not allowed: {list(procs.keys())}"                    header(f"{self.__repr__()}.sumprod(key={key})", width=125)        summaryFunc = partial(self.dbio.sumprodio.make, key=key, verbose=True)        summaryFunc()                    ###########################################################################    # Match    ###########################################################################    def matchprod(self, *arg, **kwargs) -> 'None':        header(f"{self.__repr__()}.matchprod", width=125)        matchFunc = partial(self.dbio.matchprodio.make, verbose=True)        matchFunc()        ###########################################################################    # TQDM Wrapper    ###########################################################################    def tqdmMap(self, func, modVals) -> 'list':        pool = Pool(processes=self.nProcs)        result_list_tqdm = []        for result in tqdm(pool.imap(func=func, iterable=modVals), total=len(modVals)):            result_list_tqdm.append(result)        del pool        return result_list_tqdm    