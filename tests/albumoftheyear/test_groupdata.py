from dbbase import MusicDBRootDataIO, MusicDBDir, MusicDBData, getModValsfrom dbparse import MusicDBGroupDataIO, ParseFileType, MergeFileType, ConcatFileTypefrom musicdb.albumoftheyear import MusicDBParamsdef test_parseinputdata():    params = MusicDBParams()    rdio = MusicDBRootDataIO(db=params.db)        #######################################################################    # Raw ParseType Inputs    #######################################################################    for parseTypeKey, parseType in params.parseMap.items():        assert isinstance(parseType, ParseFileType), f"parseType [{parseType}] is not a ParseFileType"                    inputNames = []        if isinstance(parseType.inputName, str) and parseType.inputName not in ["SearchArtist"]:            inputNames = [parseType.inputName]        elif isinstance(parseType.inputName, list):            inputNames = parseType.inputName            for inputName in inputNames:            key = f"Raw{inputName}ModVal"            dbdir = rdio.getDBDir("RawModVal")            datadir = MusicDBDir(path=dbdir, child=f"{inputName.lower()}s")            rdio.addDir(key, datadir)            for modVal in getModVals():                rdio.getDBDir(key).mkDir(modVal)                            key = f"Raw{inputName}"            datadir = rdio.getDBDir(f"Raw{inputName}ModVal")            dbdata = MusicDBData(path=datadir, arg=True)            rdio.addData(key, dbdata, addname=True)                        key = f"Raw{inputName}ModVal"            datadir = rdio.getDBDir(f"Raw{inputName}ModVal")            dbdata = MusicDBData(path=datadir, arg=True)            rdio.addData(key, dbdata, addname=True)                def test_parseoutputdata():    params = MusicDBParams()    rdio = MusicDBRootDataIO(db=params.db)    ########################################################################################################################    # Shuffle/ModVal ParseType Outputs    ########################################################################################################################    for parseTypeKey, parseType in params.parseMap.items():        assert isinstance(parseType, ParseFileType), f"parseType [{parseType}] is not a ParseFileType"                parseOutput = parseType.getOutput(level=1)        assert isinstance(parseOutput, dict), f"parseOutput [{parseOutput}] is not a dict"        for outputName, (outputLevel, outputFormat) in parseOutput.items():            key = f"ModVal{outputName}"            dbdir = rdio.getDBDir("ModVal")            datadir = MusicDBDir(path=dbdir, child=f"{outputName.lower()}")            rdio.addDir(key, datadir)            rdio.getDBDir(key).mkDir()                        key = f"ModVal{outputName}"            datadir = rdio.getDBDir(key)            dbdata = MusicDBData(path=datadir, arg=True, suffix="DB")            rdio.addData(key, dbdata, addname=True)                    parseOutput = parseType.getOutput(level=2)        assert isinstance(parseOutput, dict), f"parseOutput [{parseOutput}] is not a dict"        for outputName, (outputLevel, outputFormat) in parseOutput.items():            key = f"{outputName}Base"            dbdir = rdio.getDBDir("ModVal")            datadir = MusicDBDir(path=dbdir, child=f"{outputName.lower()}")            rdio.addDir(key, datadir)            rdio.getDBDir(key).mkDir()                        key = outputName            dbdir = rdio.getDBDir(f"{outputName}Base")            datadir = MusicDBDir(path=dbdir, arg=True)            rdio.addDir(key, datadir)                        key = outputName            datadir = rdio.getDBDir(f"{outputName}")            dbdata = MusicDBData(path=datadir, arg=True, suffix=f"{outputName}-DB")            rdio.addData(key, dbdata, addname=True)            for modVal in getModVals():                rdio.getDBDir(key).mkDir(modVal)                                                      def test_mergeoutputdata():    params = MusicDBParams()    rdio = MusicDBRootDataIO(db=params.db)    ########################################################################################################################    # Shuffle/ModVal Merge Output    ########################################################################################################################    for mergeTypeKey, mergeType in params.mergeMap.items():        if not isinstance(mergeType, MergeFileType):            continue                mergeOutput = mergeType.getOutput()        assert isinstance(mergeOutput, dict), f"mergeOutput [{mergeOutput}] is not a dict"        for mergeOutputName, (mergeOutputLevel, mergeOutputFormat) in mergeOutput.items():            if mergeOutputLevel == 0:                continue            assert isinstance(mergeOutputName, str), f"MergeOutputName [{mergeOutputName}] is not a string"                        key = f"ModVal{mergeOutputName}"            dbdir = rdio.getDBDir("ModVal")            datadir = MusicDBDir(path=dbdir, child=f"{mergeOutputName.lower()}")            rdio.addDir(key, datadir)            rdio.getDBDir(key).mkDir()                        key = f"ModVal{mergeOutputName}"            datadir = rdio.getDBDir(f"ModVal{mergeOutputName}")            dbdata = MusicDBData(path=datadir, arg=True, suffix="DB")            rdio.addData(key, dbdata, addname=True)def test_mergeinputdata():    params = MusicDBParams()    rdio = MusicDBRootDataIO(db=params.db)    ########################################################################################################################    # Shuffle/ModVal Merge Inputs (assert existance because it should be created in previous step)    ########################################################################################################################    mergeChecks = []    for mergeTypeKey,mergeType in params.mergeMap.items():        assert isinstance(mergeType, (MergeFileType, dict)), f"mergeType [{mergeType}] is not a (MergeFileType, dict)"                if isinstance(mergeType,MergeFileType):            inputNames = mergeType.inputName if isinstance(mergeType.inputName, list) else [mergeType.inputName]            mergeChecks.append([mergeTypeKey, mergeType.inputType, inputNames])        elif isinstance(mergeType,dict):            for mergeSubTypeKey,mergeSubType in mergeType.items():                if isinstance(mergeSubType, MergeFileType):                    inputNames = mergeSubType.inputName if isinstance(mergeSubType.inputName, list) else [mergeSubType.inputName]                    mergeChecks.append([mergeSubTypeKey, mergeSubType.inputType, inputNames])                elif isinstance(mergeSubType,list):                    for mergeSubSubType in mergeSubType:                        if isinstance(mergeSubSubType,MergeFileType):                            inputNames = mergeSubSubType.inputName if isinstance(mergeSubSubType.inputName, list) else [mergeSubSubType.inputName]                            mergeChecks.append([mergeSubTypeKey, mergeSubSubType.inputType, inputNames])                        else:                            raise TypeError(f"MergeSubTypeKey [{mergeSubTypeKey}] list entry is not a MergeFileType [{type(mergeSubSubType)}] object")    for (mergeTypeKey, inputType, inputNames) in mergeChecks:        for inputName in inputNames:            dbKey = f"ModVal{inputName}" if inputType in ["Artist", "ArtistConcat", "Media","Profile"] else f"{inputName}"            dbdir = rdio.getDBDir(dbKey)            assert isinstance(dbdir, MusicDBDir), f"MergeTypeKey [{mergeTypeKey}] input [{dbKey}] is not previously defined in ParseMap"                        def test_concatoutputdata():    params = MusicDBParams()    rdio = MusicDBRootDataIO(db=params.db)    ########################################################################################################################    # Shuffle/ModVal Concat Output    ########################################################################################################################    for concatTypeKey,concatType in params.concatMap.items():                if not isinstance(concatType,ConcatFileType):            continue                    concatOutput = concatType.getOutput()        assert isinstance(concatOutput, dict), f"concatOutput [{concatOutput}] is not a dict"        for concatOutputName,(concatOutputLevel, concatOutputFormat) in concatOutput.items():            if concatOutputLevel == 0:                continue            assert isinstance(concatOutputName,str), f"ConcatOutputName [{concatOutputName}] is not a string"            key = f"ModVal{concatOutputName}"            dbdir = rdio.getDBDir("ModVal")            datadir = MusicDBDir(path=dbdir, child=f"{concatOutputName.lower()}")            rdio.addDir(key, datadir)            rdio.getDBDir(key).mkDir()            key = f"ModVal{concatOutputName}"            datadir = rdio.getDBDir(f"ModVal{concatOutputName}")            dbdata = MusicDBData(path=datadir, arg=True, suffix="DB")            rdio.addData(key, dbdata, addname=True)def test_groupdata():    params = MusicDBParams()    rdio = MusicDBRootDataIO(db=params.db)    gdio = MusicDBGroupDataIO(rdio, params)    gdio.addGroupData()if __name__ == "__main__":    test_groupdata()    #test_parseinputdata()    #test_parseoutputdata()    #test_mergeinputdata()    #test_mergeoutputdata()    #test_concatoutputdata()                