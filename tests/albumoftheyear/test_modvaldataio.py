from musicdb.albumoftheyear import MusicDBIO, MusicDBParamsfrom dbbase import MusicDBModValDataIOfrom utils import FileInfofrom pandas import DataFrame, Seriesimport warnings    def test_modvaldataio():    mdbio = MusicDBIO()    mvdataio = MusicDBModValDataIO(mdbio.rdio)    modVal = 0    def testdatanoarg(modVal, outputFormat):        finfo = mvdataio.getFile(modVal)        assert isinstance(finfo, FileInfo), f"finfo [{finfo}] is not a FileInfo"        exists = mvdataio.exists(modVal)        if exists is True:            data = mvdataio.get(modVal)            assert isinstance(data, eval(outputFormat)), f"ModValData [{type(data)}] is not a {outputFormat}"        else:            warnings.warn("finfo [{finfo}] does not exist!")                def testdataarg(modVal, outputName, outputFormat):        finfo = mvdataio.getFile(modVal, outputName)        assert isinstance(finfo, FileInfo), f"finfo [{finfo}] is not a FileInfo"        exists = mvdataio.exists(modVal, outputName)        if exists is True:            data = mvdataio.get(modVal, outputName)            assert isinstance(data, eval(outputFormat)), f"ModValData [{type(data)}] is not a {outputFormat}"        else:            warnings.warn("finfo [{finfo}] does not exist!")            params = MusicDBParams()    for parseName, parseType in params.parseMap.items():        print(parseName, parseType)        for outputName, (outputLevel, outputFormat) in parseType.getOutput(level=0).items():            testdatanoarg(modVal, outputFormat)        for outputName, (outputLevel, outputFormat) in parseType.getOutput(level=1).items():            testdataarg(modVal, outputName, outputFormat)                    for concatName, concatType in params.concatMap.items():        print(concatName, concatType)        for outputName, (outputLevel, outputFormat) in concatType.getOutput().items():            testdataarg(modVal, outputName, outputFormat)                if __name__ == "__main__":    test_modvaldataio()    